logging {
  level = "info"
  format = "logfmt"
}

livedebugging {
  enabled = true
}

// ----------------
// Discoveries
// ----------------

discovery.kubernetes "pods" {
  role = "pod"
  // Restrict to pods on the node to reduce cpu & memory usage
  selectors {
    role = "pod"
    field = "spec.nodeName=" + coalesce(sys.env("HOSTNAME"), constants.hostname)
  }
}

// ----------------
// Metrics
// ----------------

prometheus.remote_write "default" {
  endpoint {
    url = sys.env("PROMETHEUS_REMOTE_WRITE_URL")
    headers = {
      "X-Scope-OrgID" = sys.env("CLUSTER_NAME"),
    }
  }
  external_labels = {
    cluster = sys.env("CLUSTER_NAME"),
  }
}

mimir.rules.kubernetes "default" {
  address = sys.env("MIMIR_RULER_URL")
  tenant_id = sys.env("CLUSTER_NAME")
}

prometheus.operator.servicemonitors "default" {
  forward_to = [prometheus.remote_write.default.receiver]
  clustering {
    enabled = true
  }
}

prometheus.operator.podmonitors "default" {
  forward_to = [prometheus.remote_write.default.receiver]
  clustering {
    enabled = true
  }
}

prometheus.exporter.self "default" {}

prometheus.scrape "self" {
  targets    = prometheus.exporter.self.default.targets
  forward_to = [prometheus.remote_write.default.receiver]
}

// ----------------
// Log Forwarding
// ----------------

loki.write "default" {
  endpoint {
    url = sys.env("LOKI_REMOTE_WRITE_URL")
    tenant_id = sys.env("CLUSTER_NAME")
  }
  external_labels = {
    cluster = sys.env("CLUSTER_NAME"),
  }
}

// ----------------
// Pod Logs
// ----------------

discovery.relabel "pod_logs" {
  targets = discovery.kubernetes.pods.targets

  rule {
    source_labels = ["__meta_kubernetes_namespace"]
    action = "replace"
    target_label = "namespace"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_name"]
    action = "replace"
    target_label = "pod"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_container_name"]
    action = "replace"
    target_label = "container"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
    action = "replace"
    target_label = "app"
  }
  rule {
    source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
    action = "replace"
    target_label = "job"
    separator = "/"
    replacement = "$1"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
    action = "replace"
    target_label = "__path__"
    separator = "/"
    replacement = "/var/log/pods/*$1/*.log"
  }
  rule {
    source_labels = ["__meta_kubernetes_pod_container_id"]
    action = "replace"
    target_label = "container_runtime"
    regex = "^(\\S+):\\/\\/.+$"
    replacement = "$1"
  }
}

local.file_match "pod_logs" {
  path_targets = discovery.relabel.pod_logs.output
}

loki.source.file "pod_logs" {
  targets    = local.file_match.pod_logs.targets
  forward_to = [loki.write.default.receiver]
}

// ----------------
// Cluster Events
// ----------------

loki.source.kubernetes_events "cluster_events" {
  job_name   = "integrations/kubernetes/eventhandler"
  log_format = "logfmt"
  forward_to = [
    loki.write.default.receiver,
  ]
}

// ----------------
// Open Telemetry Exporters and Receivers
// ----------------

otelcol.exporter.otlphttp "default" {
  client {
    endpoint = sys.env("OTEL_HTTP_EXPORTER_URL")
    headers = {
      "X-Scope-OrgID" = sys.env("CLUSTER_NAME"),
    }
  }
  sending_queue {
    // batch を有効にする
    batch {}
  }

}

otelcol.receiver.otlp "default" {
  grpc {
    endpoint = "0.0.0.0:4317"
  }
  http {
    endpoint = "0.0.0.0:4318"
  }
  output {
    traces  = [otelcol.processor.memory_limiter.default.input]
  }
}

// ----------------
// Open Telemetry Processors
// ----------------

otelcol.processor.memory_limiter "default" {
  check_interval = "1s"
  limit = sys.env("OTEL_MEMORY_LIMIT")

  output {
    traces  = [otelcol.processor.probabilistic_sampler.default.input]
  }
}

otelcol.processor.probabilistic_sampler "default" {
  sampling_percentage = sys.env("OTEL_SAMPLING_RATE")

  output {
    traces  = [otelcol.processor.k8sattributes.default.input]
  }
}


otelcol.processor.k8sattributes "default" {
  extract {
    otel_annotations = true
    metadata = [
      "k8s.namespace.name",
      "k8s.deployment.name",
      "k8s.statefulset.name",
      "k8s.daemonset.name",
      "k8s.cronjob.name",
      "k8s.job.name",
      "k8s.node.name",
      "k8s.pod.name",
      "k8s.container.name",
    ]
  }

  output {
    traces  = [otelcol.processor.transform.external_labels.input]
  }
}

otelcol.processor.transform "external_labels" {
  trace_statements {
    context = "resource"
    statements = [
      string.format(`set(resource.attributes["k8s.cluster.name"], %q)`, sys.env("CLUSTER_NAME")),
    ]
  }
  output {
    traces  = [otelcol.exporter.otlphttp.default.input]
  }
}
